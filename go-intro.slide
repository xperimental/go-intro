Go Intro
A short introduction
18 Apr 2018
Tags: golang, workshop

Robert Jacob
https://github.com/xperimental/go-intro/tree/short
@xperimental

* History

Go is a programming language that originated at Google but is now open-source.

- Announced November 2009
- Go 1.0 March 2012
- Currently: Go 1.10.1 (2018-03-28)

It is just called "Go" but everyone is using "golang" to search for it online to reduce the false-positives.

* Features

- Static typing
- Type inference
- CSP-style concurrency (Goroutines & Channels)
- Garbage collection
- Easy cross-compilation
- Very fast compile
- Extensive standard library

: CSP = communicating sequential processes

* Obligatory Hello World

.play examples/hello.go

* Hello World Explanation

.play examples/hello.go

- `package` defines a namespace ("package")
- `import` makes public contents of other packages usable in current one
- `func` defines functions
- `main.main()` is where program execution starts

* Variables

- Variables store values of a certain type which can not change ("static typing")
- The compiler tries to infer the type if you omit it during declaration
- Inside functions there is a short-cut `:=`

.play -edit examples/vars/vars.go /START OMIT/,/END OMIT/

- Pointers also do exist, they are also statically typed (be aware of `nil`):

.play examples/vars/pointers.go /START OMIT/,/END OMIT/

- There is no pointer arithmetic (like in C), so ðŸŽ‰

* Variables - Structures

Complex variables can be created using `struct` types:

.play examples/vars/vars-structs.go /START OMIT/,/END OMIT/

* Constants

- Typed like variables
- Only simple types
- Can not change value (compile error)
- Only outside of functions

.play examples/vars/constants.go /START OMIT/,/END OMIT/

* Flow Control - If / Switch

- `if` can be used to check for conditions:

.play -edit examples/flow/flow-if.go /START OMIT/,/END OMIT/

- `switch` can be used to combine multiple `if`-`else` blocks:

.play examples/flow/flow-switch-basic.go /START OMIT/,/END OMIT/

* Flow Control - Loops

- Classic `for`:

.play examples/flow/flow-for-classic.go /START OMIT/,/END OMIT/

- Range (with array):

.play examples/flow/flow-for-range.go /START OMIT/,/END OMIT/

- Endless:

.play examples/flow/flow-for-endless.go /START OMIT/,/END OMIT/

- Yes, there is only `for` ðŸ™‚

* Functions

Define using `func`, call using `name()`:

.play examples/functions/functions.go /START OMIT/,/END OMIT/

You can pass parameters to functions:

.play examples/functions/functions-params.go /START OMIT/,/END OMIT/

* Functions - Multiple Return values

Functions can return more than one result:

.play -edit examples/functions/functions-return-multi.go /START OMIT/,/END OMIT/

*Note:* This does not define a "tuple", just two distinct return values.

* Packages

Packages can be used to break up programs into components that can be reused and shared:

- One directory = one package
- Directory name = package name (`main` is special).

Items (variables, constants, functions) can be public or private:

- Use `import` to use public items of other packages.
- Leading character decides if private or public:

.code examples/public-private.go /START OMIT/,/END OMIT/

* Package Names

- Runtime packages (examples):

 fmt
 net/http

- External packages (full path):

 golang.org/x/crypto/ssh
 github.com/gorilla/mux

Download external packages using "go get":

 go get golang.org/x/crypto/ssh

But where are they downloaded to?

* $GOPATH

- Local directory (default = `$HOME/go`)
- Single repository for "all Go code"
- Three subdirectories (`src`, `pkg` and `bin`)

 /home/xperimental/
 â”‚
 â””â”€â”€ go
     â”‚
     â”œâ”€â”€ src (sources)
     â”‚
     â”œâ”€â”€ pkg (package object files)
     â”‚
     â””â”€â”€ bin (built executables)

* $GOPATH (continued)

.code gopath.txt

* Â 

.background imgs/break.jpg

* Goroutines

The `go` keyword runs functions asynchronously:

.play examples/goroutines/goroutines.go /START OMIT/,/END OMIT/

* Channels

- Messaging between Goroutines
- Typed
- Blocking by default

.play examples/goroutines/channels.go /START OMIT/,/END OMIT/

* Channels - Buffering

You can define a buffer when making a channel:

.play -edit examples/goroutines/channels-buffered.go /START OMIT/,/END OMIT/

* Channels - Loops

Channels can be used like an array in a `for` loop:

.play -edit examples/goroutines/channels-for.go /START OMIT/,/END OMIT/

* Arrays

Arrays can contain a fixed number of elements of a certain type.

.play examples/vars/arrays.go /START OMIT/,/END OMIT/

The built-in `len()` function can be used to get the array length.

.play examples/vars/arrays-len.go /START OMIT/,/END OMIT/

* Slices

- Slices are "views" on a backing array. They can be resized.

.play -edit examples/vars/slices.go /START OMIT/,/END OMIT/

- The `len()` built-in also works on slices. There is an additional `cap()` built-in function that shows the size of the backing array.
- Most of the time you will work with slices on an "anonymous" array.

.play examples/vars/slices-anon.go /START OMIT/,/END OMIT/

* Append

- `append()` can be used to append elements to a slice.
- If the backing array of the slice is too small (or even `nil`), a new one is allocated.

.play -edit examples/vars/slices-append.go /START OMIT/,/END OMIT/

- Append will overwrite values in the middle of an array!
- Avoid write operations on slices that share a common array.

.play examples/vars/slices-overlap.go /START OMIT/,/END OMIT/

* Maps

- The `map` type can be used to create associative arrays:

.play examples/vars/maps.go /START OMIT/,/END OMIT/

Map variables are pointers. The uninitialized `nil` value is not interchangable with an empty map, because it can not be directly written to:

.play examples/vars/maps-nil.go /START OMIT/,/END OMIT/

Be aware that multiple variables can point to the same map when doing modifications:

.play examples/vars/maps-pointer.go /START OMIT/,/END OMIT/

* Methods

Go is not object-oriented. But you can "attach" functions to any type using so-called receivers making them "methods":

.play examples/functions/functions-receiver.go /START OMIT/,/END OMIT/

Receivers can be values or pointers, your use-case determines which you need.

: Mention that this works not just with structs but with any type.

* Interfaces

- Interfaces define a set of method signatures.
- No need to explicitly "implement" an interface ("duck typing").

.play examples/interfaces/interfaces.go /START OMIT/,/END OMIT/

- Duck typing even works across package boundaries (i.e. "not your code")

.play examples/interfaces/interfaces-duck.go /START OMIT/,/END OMIT/

: Convention is to output concrete type and take interface as input (if needed).

* Error Handling

- If your function can cause an error, return a value of type `error` as the last return value:

.code examples/errors/errors.go /START OMIT/,/END OMIT/

- Error messages should have no punctuation and start lower-case for concatenation:

    user, err := db.Get(userID)
    if err != nil {
        return fmt.Errorf("error while getting user: %s", err)
    }
    --> error while getting user: database error: connection timed out

* Dependency Management

By default Go has a problem with handling dependencies:

- `$GOPATH` stores all source
- Standard "go get" gets packages including all dependencies, but
- "go get" retrieves the current `master` version
- Only repositories missing from `$GOPATH` are retrieved by "go get"

So a few tools were invented:

- govendor (what I started with)
- godep
- Glide
- dep (what I presently use, currently version 0.4.1)
- vgo (what might be the future)

* Vendoring

- Vendoring means having a copy of all your dependencies.
- Go 1.5 made vendoring a part of the tooling. When a directory in the source tree is called "vendor" its subpaths behave special:

.code vendor.txt

- In this case `main.go` would use the "pflag" package from the vendor directory and not the general one.

* Using dep

Initialize a project. This will respect current dependencies and convert from previous tools:

    dep init

See current status:

    dep status

Add a new dependency:

    dep ensure -add github.com/spf13/pflag@1.0.0

Update state of vendoring directory (idempotent after first run):

    dep ensure

Update all dependencies respecting "constraints":

    dep ensure -update

* What's More?

- Struct Composition
- Type Assertions / Type Switches
- Advanced Concurrency with Goroutines and Channels
- Cross-Compilation
- Struct Tags
