Go Intro (Short Version)
An interactive introduction
03 Aug 2019
Tags: golang, workshop

Robert Jacob
https://github.com/xperimental/go-intro
@xperimental

* History

Go is a programming language that originated at Google.

It is just called "Go" but everyone is using "golang" to search for it online to reduce the false-positives.

- Announced November 2009
- Go 1.0 March 2012
- Current: Go 1.12.7 (2019-07-08)
- Next Major: Go 1.13 (Later this month)

* Features

- Static typing
- Type inference
- CSP-style concurrency (Goroutines & Channels)
- Garbage collection
- Easy cross-compilation
- Very fast compile
- Extensive standard library

* Obligatory Hello World

.play -edit examples/hello.go

* Hello World Explanation

.play examples/hello.go

- `package` defines a namespace ("package")
- `import` makes public contents of other packages usable in current one
- `func` defines functions
- `main.main()` is where program execution starts

* Visibility

Go only has two visibilities:

- package private
- Public

Everything that has a capital first letter will be `Public`, everything else is `private`:

.code examples/public-private.go /START OMIT/,/END OMIT/

* Variables

Variables store values of a certain type. The type of a variable can not change during execution ("static typing").

.code examples/vars/vars.go /START OMIT/,/END OMIT/

The compiler tries to infer the type if you omit it during declaration:

.play -edit examples/vars/vars-notype.go /START OMIT/,/END OMIT/

Inside functions there is a short-cut for new variables:

.play examples/vars/vars-short.go /START OMIT/,/END OMIT/

* Variables - Pointers

Pointers are variables which contain an address of another variable. Pointers can be used with all types, and are also statically typed:

.play examples/vars/pointers.go /START OMIT/,/END OMIT/

They can be `nil` to point to nothing, but this creates an error when you try to access ("dereference") it:

.play -edit examples/vars/pointers-nil.go /START OMIT/,/END OMIT/

But there is no pointer arithmetic (unlike C), so ðŸŽ‰

* Variables - Structures

Complex variables can be created using `struct` types:

.play examples/vars/vars-structs.go /START OMIT/,/END OMIT/

* Constants

- Typed like variables
- Only simple types
- Can not change value (compile error)
- Only outside of functions (package scope)
- Floating-point numbers have arbitrary precision (not limited to `float64`)

.play -edit examples/vars/constants.go /START OMIT/,/END OMIT/

* Flow Control - If

`if` can be used to check for conditions:

.play -edit examples/flow/flow-if.go /START OMIT/,/END OMIT/

* Flow Control - Switch

`switch` can be used to combine multiple `if`-`else` blocks:

.play examples/flow/flow-switch-basic.go /START OMIT/,/END OMIT/

* Flow Control - Switch Without Variable

If used without variable, the case statements need to be booleans:

.play examples/flow/flow-switch-bare.go /START OMIT/,/END OMIT/

* Flow Control - Loops

- Classic `for`:

.play examples/flow/flow-for-classic.go /START OMIT/,/END OMIT/

- Range (with array):

.play examples/flow/flow-for-range.go /START OMIT/,/END OMIT/

- Endless:

.play examples/flow/flow-for-endless.go /START OMIT/,/END OMIT/

* Flow Control - Scoped Variables

You can create new variables inside blocks (if, switch, for), which are only available in the block:

.play -edit examples/flow/flow-if-variable.go /START OMIT/,/END OMIT/

* Functions

Define using `func`, call using name:

.play examples/functions/functions.go /START OMIT/,/END OMIT/

You can pass parameters to functions:

.play examples/functions/functions-params.go /START OMIT/,/END OMIT/

* Functions - Multiple Return values

Functions can return more than one result:

.play -edit examples/functions/functions-return-multi.go /START OMIT/,/END OMIT/

* Error Handling

If your function can cause an error, return a value of type `error` as the last return value:

.code examples/errors/errors.go /START OMIT/,/END OMIT/

This encourages handling errors close to where they happen instead of "bubbling up" to surrounding code.

* Packages

Packages can be used to break up programs into components that can be reused and shared:

- One directory = one package
- Convention: directory name = package name
- `main` is special: will generate an executable

* Package Names

- Runtime packages (examples):

 fmt
 net/http

- External packages (full path):

 golang.org/x/crypto/ssh
 github.com/gorilla/mux

Download external packages using "go get":

 go get -m golang.org/x/crypto/ssh

But where are they downloaded to?

* Go Modules

* Goroutines

Go can run functions asynchronous:

.play examples/goroutines/goroutines.go /START OMIT/,/END OMIT/

* Channels

- Messaging between Goroutines
- Typed
- Blocking by default

.play examples/goroutines/channels.go /START OMIT/,/END OMIT/

* Channels - Buffering

You can define a buffer when making a channel:

.play -edit examples/goroutines/channels-buffered.go /START OMIT/,/END OMIT/

* Channels - Loops

Channels can be used like an array in a `for` loop:

.play -edit examples/goroutines/channels-for.go /START OMIT/,/END OMIT/

* What's More?

- Interfaces
- Cross-Compilation
- Struct Composition
- Struct Tags
- Function Receivers
- Type Assertions / Type Switches
- Advanced Concurrency with Goroutines and Channels

* Q & A

* Overflow slides

* Arrays

Arrays can contain a fixed number of elements of a certain type.
They can not be resized.

.play examples/vars/arrays.go /START OMIT/,/END OMIT/

The built-in `len()` function can be used to get the array length.

.play examples/vars/arrays-len.go /START OMIT/,/END OMIT/

* Slices

Slices are "views" on a backing array. They can be resized.

.play -edit examples/vars/slices.go /START OMIT/,/END OMIT/

The `len()` built-in also works on slices. There is an additional `cap()` built-in function that shows the size of the backing array.

* Append

`append()` can be used to append elements to a slice. If the backing array of the slice is too small (or even `nil`), a new one is allocated.

.play -edit examples/vars/slices-append.go /START OMIT/,/END OMIT/

Append will overwrite values in the middle of an array! Be aware of this when using multiple slices on the same array:

.play examples/vars/slices-overlap.go /START OMIT/,/END OMIT/

Most of the time you will work with slices on an array that you did not create yourself.

* Maps

The `map` type can be used to create associative arrays:

.play examples/vars/maps.go /START OMIT/,/END OMIT/

Map variables are pointers. The uninitialized `nil` value is not interchangable with an empty map, because it can not be directly written to:

.play examples/vars/maps-nil.go /START OMIT/,/END OMIT/

Be aware that multiple variables can point to the same map when doing modifications:

.play examples/vars/maps-pointer.go /START OMIT/,/END OMIT/

* Methods

Go is not object-oriented. But you can "attach" functions to any type using so-called receivers making them "methods":

.play examples/functions/functions-receiver.go /START OMIT/,/END OMIT/

Receivers can be values or pointers, your use-case determines which you need.

: Mention that this works not just with structs but with any type.

* Interfaces

Interfaces define a set of method signatures. Any type that implements the methods can be used as the interface type.

.play examples/interfaces/interfaces.go /START OMIT/,/END OMIT/

* Interfaces - Duck Typing

There is no need to state that a type implements an interface. If the methods are present, the compiler will recognize it. Even across package boundaries:

.play examples/interfaces/interfaces-duck.go /START OMIT/,/END OMIT/

* Error Messages

The message returned by `Error()` should have no punctuation and start lower-case, so they can be cascaded by surrounding code:

    user, err := db.Get(userID)
    if err != nil {
        return fmt.Errorf("error while getting user: %s", innerErr)
    }
    --> error while getting user: database error: connection timed out

* Custom Error Types

`error` is a built-in interface. The definition looks like this:

    type error interface {
        Error() string
    }

Because it is an interface, custom error types can be defined:

.code examples/errors/errors-custom.go /START OMIT/,/END OMIT/

: Custom error types are typically used to convey more information to surrounding error handling code, if that is not needed a generic error is usually fine.
