Go Intro (Short Version)
An interactive introduction
03 Aug 2019
Tags: golang, workshop

Robert Jacob
https://github.com/xperimental/go-intro
@xperimental

* History

Go is a programming language that originated at Google.

It is just called "Go" but everyone is using "golang" to search for it online to reduce the false-positives.

- Announced November 2009
- Go 1.0 March 2012
- Current: Go 1.12.7 (2019-07-08)
- Next Major: Go 1.13 (Later this month)

* Features

- Static typing
- Type inference
- CSP-style concurrency (Goroutines & Channels)
- Garbage collection
- Easy cross-compilation
- Very fast compile
- Extensive standard library

* Obligatory Hello World

.play examples/hello.go

* Hello World Explanation

.play examples/hello.go

- `package` defines a namespace ("package")
- `import` makes public contents of other packages usable in current one
- `func` defines functions
- `main.main()` is where program execution starts

* Variables

Variables store values of a certain type. The type of a variable can not change during execution ("static typing").

.code examples/vars/vars.go /START OMIT/,/END OMIT/

The compiler tries to infer the type if you omit it during declaration:

.play -edit examples/vars/vars-notype.go /START OMIT/,/END OMIT/

Inside functions there is a short-cut for new variables:

.play examples/vars/vars-short.go /START OMIT/,/END OMIT/

* Variables - Pointers

Pointers are variables which contain an address of another variable. Pointers can be used with all types, and are also statically typed:

.play examples/vars/pointers.go /START OMIT/,/END OMIT/

They can be `nil` to point to nothing, but this creates an error when you try to access ("dereference") it:

.play -edit examples/vars/pointers-nil.go /START OMIT/,/END OMIT/

But there is no pointer arithmetic (like in C), so ðŸŽ‰

* Variables - Structures

Complex variables can be created using `struct` types:

.play examples/vars/vars-structs.go /START OMIT/,/END OMIT/

* Constants

- Typed like variables
- Only simple types
- Can not change value (compile error)
- Only outside of functions

.play examples/vars/constants.go /START OMIT/,/END OMIT/

* Flow Control - If

`if` can be used to check for conditions:

.play -edit examples/flow/flow-if.go /START OMIT/,/END OMIT/

* Flow Control - Switch

`switch` can be used to combine multiple `if`-`else` blocks:

.play examples/flow/flow-switch-basic.go /START OMIT/,/END OMIT/

* Flow Control - Switch Without Variable

If used without variable, the case statements need to be booleans:

.play examples/flow/flow-switch-bare.go /START OMIT/,/END OMIT/

* Flow Control - Loops

- Classic `for`:

.play examples/flow/flow-for-classic.go /START OMIT/,/END OMIT/

- Range (with array):

.play examples/flow/flow-for-range.go /START OMIT/,/END OMIT/

- Endless:

.play examples/flow/flow-for-endless.go /START OMIT/,/END OMIT/

* Flow Control - Scoped Variables

You can create new variables inside blocks (if, switch, for), which are only available in the block:

.play -edit examples/flow/flow-if-variable.go /START OMIT/,/END OMIT/

* Functions

Define using `func`, call using name:

.play examples/functions/functions.go /START OMIT/,/END OMIT/

You can pass parameters to functions:

.play examples/functions/functions-params.go /START OMIT/,/END OMIT/

* Functions - Multiple Return values

Functions can return more than one result:

.play -edit examples/functions/functions-return-multi.go /START OMIT/,/END OMIT/

* Packages

Packages can be used to break up programs into components that can be reused and shared:

- One directory = one package
- Directory name = package name (`main` is special).

Items (variables, constants, functions) can be public or private:

- Use `import` to use public items of other packages.
- Leading character decides if private or public:

.code examples/public-private.go /START OMIT/,/END OMIT/

* Package Names

- Runtime packages (examples):

 fmt
 net/http

- External packages (full path):

 golang.org/x/crypto/ssh
 github.com/gorilla/mux

Download external packages using "go get":

 go get golang.org/x/crypto/ssh

But where are they downloaded to?

* $GOPATH

- Local directory (default = `$HOME/go`)
- Single repository for "all Go code"
- Three subdirectories (`src`, `pkg` and `bin`)

 /home/xperimental/
 â”‚
 â””â”€â”€ go
     â”‚
     â”œâ”€â”€ src (sources)
     â”‚
     â”œâ”€â”€ pkg (package object files)
     â”‚
     â””â”€â”€ bin (built executables)

* $GOPATH (continued)

.code gopath.txt

* Â 

.background imgs/break.jpg

* Goroutines

Go can run functions asynchronous:

.play examples/goroutines/goroutines.go /START OMIT/,/END OMIT/

* Channels

- Messaging between Goroutines
- Typed
- Blocking by default

.play examples/goroutines/channels.go /START OMIT/,/END OMIT/

* Channels - Buffering

You can define a buffer when making a channel:

.play -edit examples/goroutines/channels-buffered.go /START OMIT/,/END OMIT/

* Channels - Loops

Channels can be used like an array in a `for` loop:

.play -edit examples/goroutines/channels-for.go /START OMIT/,/END OMIT/

* What's More?

- Interfaces
- Struct Composition
- Function Receivers
- Cross-Compilation
- Struct Tags
- Vendoring & Dependency Management

* Recap

- Variables
- Constants
- Flow Control: `if`, `switch`, `for`
- Functions
- Packages
- `$GOPATH`
- Basic Concurrency using Goroutines & Channels

* Arrays

Arrays can contain a fixed number of elements of a certain type.
They can not be resized.

.play examples/vars/arrays.go /START OMIT/,/END OMIT/

The built-in `len()` function can be used to get the array length.

.play examples/vars/arrays-len.go /START OMIT/,/END OMIT/

* Slices

Slices are "views" on a backing array. They can be resized.

.play -edit examples/vars/slices.go /START OMIT/,/END OMIT/

The `len()` built-in also works on slices. There is an additional `cap()` built-in function that shows the size of the backing array.

* Append

`append()` can be used to append elements to a slice. If the backing array of the slice is too small (or even `nil`), a new one is allocated.

.play -edit examples/vars/slices-append.go /START OMIT/,/END OMIT/

Append will overwrite values in the middle of an array! Be aware of this when using multiple slices on the same array:

.play examples/vars/slices-overlap.go /START OMIT/,/END OMIT/

Most of the time you will work with slices on an array that you did not create yourself.

* Maps

The `map` type can be used to create associative arrays:

.play examples/vars/maps.go /START OMIT/,/END OMIT/

Map variables are pointers. The uninitialized `nil` value is not interchangable with an empty map, because it can not be directly written to:

.play examples/vars/maps-nil.go /START OMIT/,/END OMIT/

Be aware that multiple variables can point to the same map when doing modifications:

.play examples/vars/maps-pointer.go /START OMIT/,/END OMIT/

* Methods

Go is not object-oriented. But you can "attach" functions to any type using so-called receivers making them "methods":

.play examples/functions/functions-receiver.go /START OMIT/,/END OMIT/

Receivers can be values or pointers, your use-case determines which you need.

: Mention that this works not just with structs but with any type.

* Interfaces

Interfaces define a set of method signatures. Any type that implements the methods can be used as the interface type.

.play examples/interfaces/interfaces.go /START OMIT/,/END OMIT/

* Interfaces - Duck Typing

There is no need to state that a type implements an interface. If the methods are present, the compiler will recognize it. Even across package boundaries:

.play examples/interfaces/interfaces-duck.go /START OMIT/,/END OMIT/

* Error Handling

If your function can cause an error, return a value of type `error` as the last return value:

.code examples/errors/errors.go /START OMIT/,/END OMIT/

This encourages handling errors close to where they happen instead of "bubbling up" to surrounding code.

* Error Messages

The message returned by `Error()` should have no punctuation and start lower-case, so they can be cascaded by surrounding code:

    user, err := db.Get(userID)
    if err != nil {
        return fmt.Errorf("error while getting user: %s", innerErr)
    }
    --> error while getting user: database error: connection timed out

* Custom Error Types

`error` is a built-in interface. The definition looks like this:

    type error interface {
        Error() string
    }

Because it is an interface, custom error types can be defined:

.code examples/errors/errors-custom.go /START OMIT/,/END OMIT/

: Custom error types are typically used to convey more information to surrounding error handling code, if that is not needed a generic error is usually fine.

* Dependency Management

By default Go has a problem with handling dependencies:

- `$GOPATH` stores all source
- Standard "go get" gets packages including all dependencies, but
- "go get" retrieves the current `master` version
- Only repositories missing from `$GOPATH` are retrieved by "go get"

So a few tools were invented:

- govendor (what we used to use)
- godep
- Glide
- dep (what we use, currently version 0.4.1)
- vgo (what might be the future)

* Vendoring

Go 1.5 made vendoring a part of the tooling. When a directory in the source tree is called "vendor" its subpaths behave special:

.code vendor.txt

In this case `main.go` would use the "pflag" package from the vendor directory and not the general one.

* Using dep

Initialize a project. This will respect current dependencies and convert from previous tools:

    dep init

See current status:

    dep status

Add a new dependency:

    dep ensure -add github.com/spf13/pflag@1.0.0

Update state of vendoring directory (idempotent after first run):

    dep ensure

Update all dependencies respecting "constraints":

    dep ensure -update

* What's More?

- Struct Composition
- Type Assertions / Type Switches
- Advanced Concurrency with Goroutines and Channels
- Cross-Compilation
- Struct Tags
