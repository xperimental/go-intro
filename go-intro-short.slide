Go Intro (Short Version)
An interactive introduction
03 Aug 2019
Tags: golang, workshop

Robert Jacob
https://github.com/xperimental/go-intro
@xperimental

* History

Go is a programming language that originated at Google.

It is just called "Go" but everyone is using "golang" to search for it online to reduce the false-positives.

- Announced November 2009
- Go 1.0 March 2012
- Current: Go 1.12.7 (2019-07-08)
- Next Major: Go 1.13 (Later this month)

* Features

- Static typing
- Type inference
- CSP-style concurrency (Goroutines & Channels)
- Garbage collection
- Easy cross-compilation
- Very fast compile
- Extensive standard library

* Obligatory Hello World

.play -edit _examples/hello.go

* Hello World Explanation

.play -edit _examples/hello.go

- `package` defines a namespace ("package")
- `import` makes public contents of other packages usable in current one
- `func` defines functions
- `main.main()` is where program execution starts

* Visibility

Go only has two visibilities:

- package private
- Public

Everything that has a capital first letter will be `Public`, everything else is `private`:

.code _examples/public-private.go /START OMIT/,/END OMIT/

* Variables

Variables store values of a certain type. The type of a variable can not change during execution ("static typing").

.code _examples/vars/vars.go /START OMIT/,/END OMIT/

The compiler tries to infer the type if you omit it during declaration:

.play -edit _examples/vars/vars-notype.go /START OMIT/,/END OMIT/

Inside functions there is a short-cut for new variables:

.play -edit _examples/vars/vars-short.go /START OMIT/,/END OMIT/

* Variables - Pointers

Pointers are variables which contain an address of another variable. Pointers can be used with all types, and are also statically typed:

.play -edit _examples/vars/pointers.go /START OMIT/,/END OMIT/

They can be `nil` to point to nothing, but this creates an error when you try to access ("dereference") it:

.play -edit _examples/vars/pointers-nil.go /START OMIT/,/END OMIT/

But there is no pointer arithmetic (unlike C), so ðŸŽ‰

* Variables - Structures

Complex variables can be created using `struct` types:

.play -edit _examples/vars/vars-structs.go /START OMIT/,/END OMIT/

* Constants

- Typed like variables
- Only simple types
- Can not change value (compile error)
- Only outside of functions (package scope)
- Floating-point numbers have arbitrary precision (until assigned to variable)

.play -edit _examples/vars/constants.go /START OMIT/,/END OMIT/

* Flow Control - If

`if` can be used to check for conditions:

.play -edit _examples/flow/flow-if.go /START OMIT/,/END OMIT/

* Flow Control - Switch

`switch` can be used to combine multiple `if`-`else` blocks:

.play -edit _examples/flow/flow-switch-basic.go /START OMIT/,/END OMIT/

* Flow Control - Switch Without Variable

If used without variable, the case statements need to be booleans:

.play -edit _examples/flow/flow-switch-bare.go /START OMIT/,/END OMIT/

* Flow Control - Loops (there is only `for`)

- Classic `for`:

.play -edit _examples/flow/flow-for-classic.go /START OMIT/,/END OMIT/

- Range (with array):

.play -edit _examples/flow/flow-for-range.go /START OMIT/,/END OMIT/

- Endless:

.play -edit _examples/flow/flow-for-endless.go /START OMIT/,/END OMIT/

* Functions

Define using `func`, call using name:

.play -edit _examples/functions/functions.go /START OMIT/,/END OMIT/

You can pass parameters to functions:

.play -edit _examples/functions/functions-params.go /START OMIT/,/END OMIT/

* Functions - Multiple Return values

Functions can return more than one result:

.play -edit _examples/functions/functions-return-multi.go /START OMIT/,/END OMIT/

* Error Handling

If your function can cause an error, return a value of type `error` as the last return value:

.code _examples/errors/errors.go /START OMIT/,/END OMIT/

This encourages handling errors close to where they happen instead of "bubbling up" to surrounding code.

* Packages

Packages can be used to break up programs into components that can be reused and shared:

- One directory = one package
- Convention: directory name = package name
- Last "segment" of import path will become accessor (can be changed):

 import (
     "github.com/gorilla/mux"       # for example: mux.NewRouter()
     flag "github.com/spf13/pflag"  #              flag.Parse()
 )

- Using `package main` will generate an executable with name of directory
- `main` package can not be imported

* Package Names

- Runtime packages (examples):

 fmt
 net/http

- External packages (full path):

 golang.org/x/crypto/ssh
 github.com/gorilla/mux

Download external packages using "go get":

 go get -m golang.org/x/crypto/ssh

But where are they downloaded to?

* Go Modules

Go used to have a problem with dependency management:

- One single path for all projects (`$GOPATH`)
- Resolved to `master` version of all dependencies by default
- No concept of versions

Starting with Go 1.11 there's a new concept called "Go Modules" which aims to solve that:

- No `$GOPATH` anymore (can still be used for older codebases)
- `go.mod` defines current module and dependencies

.code go.mod

- `go.sum` contains hashes of resolved dependencies (for validating integrity)

* Go Modules (contd.)

Create a new module in current directory:

 go mod init <module name>

Add a new dependency (latest version):

 go get -m <import>

Update all dependencies (only patch changes):

 go get -m -u=patch

Update one dependency to latest version:

 go get -m -u <import>

List dependencies of current module:

 go list -m all

* Goroutines

Go can run functions asynchronously:

.play -edit _examples/goroutines/goroutines.go /START OMIT/,/END OMIT/

There is no manual thread management. Instead the runtime automatically multiplexes Goroutines over a pre-defined set of runtime threads.

* Channels

- Messaging between Goroutines (do not use global variables)
- Typed
- Blocking by default

.play -edit _examples/goroutines/channels.go /START OMIT/,/END OMIT/

* Channels (contd.)

You can define a buffer when making a channel:

.play -edit _examples/goroutines/channels-buffered.go /START OMIT/,/END OMIT/

Channels can be used like an array in a `for` loop:

.play -edit _examples/goroutines/channels-for.go /START OMIT/,/END OMIT/

* What's More?

- Arrays, slices and maps
- Interfaces
- Cross-Compilation
- Struct Composition
- Struct Tags
- Function Receivers
- Type Assertions / Type Switches
- Advanced Concurrency with Goroutines and Channels

* Q & A
